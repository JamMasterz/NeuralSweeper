package com.jam.neural.model;

import java.util.Arrays;
import java.util.Random;

import com.jam.util.Util;

public class Genome {
	private NodeLayer outputLayer;
	private NodeLayer[] hiddenLayers;
	private float[] previousOutput;
	private boolean isRepeating = false;
	
	/**
	 * Creates a genome based on specified criteria. A genome is a neural network, thats capable of
	 * generating an array of outputs given an array of inputs.
	 * @param numInputs	Number of inputs into this Genome
	 * @param numHiddenLayers Number of NodeLayers except the output layer
	 * @param numNodesPerHiddenLayer Number of nodes in each hidden layer
	 * @param numOutputNodes Number of output nodes from this Genome
	 */
	public Genome(int numInputs, int numHiddenLayers, int numNodesPerHiddenLayer, int numOutputNodes){
		this(null, numInputs, numHiddenLayers, numNodesPerHiddenLayer, numOutputNodes);
	}
	
	/**
	 * Creates a genome from given chromosome. A genome is a neural network, thats capable of
	 * generating an array of outputs given an array of inputs.
	 * @param chromosome Chromosome that uniquely defines this genome
	 * @param numInputs	Number of inputs into this Genome
	 * @param numHiddenLayers Number of NodeLayers except the output layer
	 * @param numNodesPerHiddenLayer Number of nodes in each hidden layer
	 * @param numOutputNodes Number of output nodes from this Genome
	 */
	public Genome(float[] chromosome, int numInputs, int numHiddenLayers, int numNodesPerHiddenLayer, int numOutputNodes){
		if (numInputs < 0) throw new IllegalArgumentException("Number of inputs must be greater than 0");
		if (numOutputNodes < 0) throw new IllegalArgumentException("Number of output nodes must be greater than 0");
		if (numNodesPerHiddenLayer < 0) throw new IllegalArgumentException("Number of nodes in hidden layers must be greater than 0");
		int hidden = (numHiddenLayers < 0) ? 0 : numHiddenLayers;

		outputLayer = new NodeLayer(numOutputNodes, (hidden == 0) ? numInputs : numNodesPerHiddenLayer);
		if (hidden > 0){
			hiddenLayers = new NodeLayer[hidden];

			//First layer is different
			hiddenLayers[0] = new NodeLayer(numNodesPerHiddenLayer, numInputs);
			for (int i = 1; i < hidden; i++){
				hiddenLayers[i] = new NodeLayer(numNodesPerHiddenLayer, numNodesPerHiddenLayer);
			}
		} else {
			hiddenLayers = null;
		}
		if (chromosome != null) setChromosome(chromosome);
	}
	
	/**
	 * Given an array of inputs, it computes the outputs using the neural network.
	 * If the result from the output nodes is the same in 2 consecutive calls of this method, a flag will be set
	 * @param inputs Inputs
	 * @return Output generated by the neural network
	 */
	//TODO: Move the binary flag elsewhere
	public float[] evalutateNetwork(float[] inputs, boolean binary){
		float[] nextLayerInput = inputs;
		
		for (int i = 0; i < hiddenLayers.length; i++){
			nextLayerInput = hiddenLayers[i].evaluateLayer(nextLayerInput, binary);
		}
		
		float[] newOutput = outputLayer.evaluateLayer(nextLayerInput, binary);
		
		if (Util.equals(newOutput, previousOutput)){
			isRepeating = true;
		} else {
			isRepeating = false;
		}
		previousOutput = newOutput;
		
		return previousOutput;
	}
	
	/**
	 * @return All genes contained in this neural network. These genes uniquely define a genome
	 */
	protected float[] getChromosome(){
		float[] chromosome = new float[getChromosomeSize()];
		
		int nextIndex = 0;
		for (int i = 0; i < hiddenLayers.length; i++){
			float[] layerGenes = hiddenLayers[i].getLayerGenes();
			System.arraycopy(layerGenes, 0, chromosome, nextIndex, layerGenes.length);
			nextIndex += layerGenes.length;
		}
		float[] outputLayerGenes = outputLayer.getLayerGenes();
		System.arraycopy(outputLayerGenes, 0, chromosome, nextIndex, outputLayerGenes.length);
		
		return chromosome;
	}
	
	/**
	 * Generates a new Genome, that can have genes from both parents. The genes could also have been mutated.
	 * @param another Another parent
	 * @return New genome with genes from both parents
	 */
	public Genome getOffspringGenome(Genome another){
		Random r = new Random();
		float[] parent1 = this.getChromosome();
		float[] parent2 = another.getChromosome();
		float[] offspring;
		
		if (!Util.randomDecision(NetworkSettings.CROSSOVER_RATE, r) || Arrays.equals(parent1, parent2)){
			offspring = new float[parent1.length];
			System.arraycopy(parent1, 0, offspring, 0, parent1.length);
		} else {
			offspring = crossoverChromosomes(parent1, parent2);
		}
		mutateChromosome(offspring);
		
		return new Genome(offspring, hiddenLayers[0].getNumInputsPerNode(), hiddenLayers.length, hiddenLayers[0].size(), outputLayer.size());
	}
	
	private void mutateChromosome(float[] chromosome){
		Random r = new Random();
		
		for (int i = 0; i < chromosome.length; i++) {
			if (Util.randomDecision(NetworkSettings.MUTATION_RATE, r)){
				chromosome[i] += Util.getRandomFloat(r, -NetworkSettings.MAX_BASE_PAIR_CHANGE, NetworkSettings.MAX_BASE_PAIR_CHANGE);
				if (chromosome[i] > NetworkSettings.MAX_WEIGHT) chromosome[i] = NetworkSettings.MAX_WEIGHT;
				if (chromosome[i] < -NetworkSettings.MAX_WEIGHT) chromosome[i] = -NetworkSettings.MAX_WEIGHT;
			}
		}
	}
	
	private float[] crossoverChromosomes(float[] one, float[] two){
		if (one.length != two.length) throw new IllegalArgumentException("The two genomes are not the same and cant be crossed");
		
		int crossoverIndex = new Random().nextInt(one.length - 1) + 1; //Exluding the 1st and last index which would result in nothing happening
		float[] result = new float[one.length];
		System.arraycopy(one, 0, result, 0, crossoverIndex);
		System.arraycopy(two, crossoverIndex, result, crossoverIndex, two.length - crossoverIndex);
		
		return result;
	}
	
	private void setChromosome(float[] chromosome){
		int nextIndex = 0;
		for (int i = 0; i < hiddenLayers.length; i++) {
			int geneLayerSize = hiddenLayers[i].getGenesSize();
			hiddenLayers[i].setLayerGenes(chromosome, nextIndex);
			nextIndex += geneLayerSize;
		}
		
		outputLayer.setLayerGenes(chromosome, nextIndex);
	}
	
	private int getChromosomeSize(){
		int size = 0;
		
		for (NodeLayer layer : hiddenLayers){
			size += layer.getGenesSize();
		}
		size += outputLayer.getGenesSize();
		
		return size;
	}
	
	/**
	 * @return Flag whether the last ticks output was the same as the output before that.
	 */
	public boolean isRepeating(){
		return isRepeating;
	}
	
	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		
		builder.append("\nNetwork:\n");
		for (int i = 0; i < hiddenLayers.length; i++){
			builder.append("Hidden layer " + i + '\n');
			builder.append(hiddenLayers[i].toString());
			builder.append('\n');
		}
		builder.append("Output layer\n");
		builder.append(outputLayer.toString());
		
		return builder.toString();
	}
}
