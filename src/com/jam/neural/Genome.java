package com.jam.neural;

import java.util.Arrays;
import java.util.Random;

import com.jam.util.Util;

public class Genome {
	private NodeLayer outputLayer;
	private NodeLayer[] hiddenLayers;
	
	public Genome(int numInputs, int numHiddenLayers, int numNodesPerHiddenLayer, int numOutputNodes){
		if (numInputs < 1) throw new IllegalArgumentException("Number of inputs must be greater than 0");
		if (numOutputNodes < 1) throw new IllegalArgumentException("Number of output nodes must be greater than 0");
		if (numNodesPerHiddenLayer < 1) throw new IllegalArgumentException("Number of nodes in hidden layers must be greater than 0");
		int hidden = (numHiddenLayers < 1) ? 0 : numHiddenLayers;
		
		if (hidden > 0){
			hiddenLayers = new NodeLayer[hidden];
			//first hidden layer has different amount of inputs
			hiddenLayers[0] = new NodeLayer(numNodesPerHiddenLayer, numInputs);
			
			for (int i = 1; i < hidden; i++){
				hiddenLayers[i] = new NodeLayer(numNodesPerHiddenLayer, numNodesPerHiddenLayer);
			}
		} else {
			hiddenLayers = null;
		}
		
		outputLayer = new NodeLayer(numOutputNodes, (hidden == 0) ? numInputs : numNodesPerHiddenLayer);
	}
	
	/**
	 * Given an array of inputs, it computers the outputs using the neural network
	 * @param inputs Inputs
	 * @return Output generated by the neural network
	 */
	public float[] evalutateNetwork(float[] inputs, boolean binary){
		float[] nextLayerInput = inputs;
		
		for (int i = 0; i < hiddenLayers.length; i++){
			nextLayerInput = hiddenLayers[i].evaluateLayer(nextLayerInput, binary);
		}
		
		return outputLayer.evaluateLayer(nextLayerInput, binary);
	}
	/**
	 * @return All genes contained in this neural network. These genes uniquely define a genome
	 */
	protected float[] getChromosome(){
		float[] chromosome = new float[getChromosomeSize()];
		
		int nextIndex = 0;
		for (int i = 0; i < hiddenLayers.length; i++){
			float[] layerGenes = hiddenLayers[i].getLayerGenes();
			System.arraycopy(layerGenes, 0, chromosome, nextIndex, layerGenes.length);
			nextIndex += layerGenes.length;
		}
		float[] outputLayerGenes = outputLayer.getLayerGenes();
		System.arraycopy(outputLayerGenes, 0, chromosome, nextIndex, outputLayerGenes.length);
		
		return chromosome;
	}
	
	public float[] getOffspringChromosome(Genome another){
		Random r = new Random();
		float[] parent1 = this.getChromosome();
		float[] parent2 = another.getChromosome();
		float[] offspring;
		
		if (!Util.randomDecision(NetworkSettings.CROSSOVER_RATE, r) || Arrays.equals(parent1, parent2)){
			offspring = new float[parent1.length];
			System.arraycopy(parent1, 0, offspring, 0, parent1.length);
		} else {
			offspring = crossoverChromosomes(parent1, parent2);
		}
		mutateChromosome(offspring);
		
		return offspring;
	}
	
	private void mutateChromosome(float[] chromosome){
		Random r = new Random();
		
		for (int i = 0; i < chromosome.length; i++) {
			if (Util.randomDecision(NetworkSettings.MUTATION_RATE, r)){
				chromosome[i] += Util.getRandomFloat(r, -NetworkSettings.MAX_BASE_PAIR_CHANGE, NetworkSettings.MAX_BASE_PAIR_CHANGE);
			}
		}
	}
	
	private float[] crossoverChromosomes(float[] one, float[] two){
		if (one.length != two.length) throw new IllegalArgumentException("The two genomes are not the same and cant be crossed");
		
		int crossoverIndex = new Random().nextInt(one.length - 1) + 1; //Exluding the 1st and last index which would result in nothing happening
		float[] result = new float[one.length];
		System.arraycopy(one, 0, result, 0, crossoverIndex);
		System.arraycopy(two, crossoverIndex, result, crossoverIndex, two.length - crossoverIndex);
		
		return result;
	}
	
	protected void setChromosome(float[] chromosome){
		int outputLayerIndex = 0;
		for (int i = 0; i < hiddenLayers.length; i++) {
			int geneLayerSize = hiddenLayers[i].getGenesSize();
			hiddenLayers[i].setLayerGenes(chromosome, i * geneLayerSize);
			outputLayerIndex += geneLayerSize;
		}
		
		outputLayer.setLayerGenes(chromosome, outputLayerIndex);
	}
	
	protected int getChromosomeSize(){
		int size = 0;
		
		for (NodeLayer layer : hiddenLayers){
			size += layer.getGenesSize();
		}
		size += outputLayer.getGenesSize();
		
		return size;
	}
	
	@Override
	public String toString() {
		StringBuilder builder = new StringBuilder();
		
		builder.append("Network: \n\n");
		for (int i = 0; i < hiddenLayers.length; i++){
			builder.append("Hidden layer " + i + '\n');
			builder.append(hiddenLayers[i].toString());
			builder.append('\n');
		}
		builder.append("Output layer ");
		builder.append(outputLayer.toString());
		
		return builder.toString();
	}
}
